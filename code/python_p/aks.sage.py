

# This file was *autogenerated* from the file Projects/python_p/aks.sage
from sage.all_cmdline import *   # import sage library

_sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_5 = Integer(5); _sage_const_100 = Integer(100)
import numpy as np
import math
import time
import matplotlib.pyplot as plt 
from sympy import perfect_power
from numpy.polynomial import polynomial as P
from scipy.special import binom
from numpy.random import randint
import timeit
from sage.all import *


"""
gcd: N x N - > N 
calculates the gcd of 2 numbers using euclid's algorithm
"""
def gcd(a,b):
	if b == _sage_const_0 :
		return a
	return gcd(b,a % b)	


"""
calculates the remainder of the polynomial division poly/r
"""
def polyRemainder(poly,r):
    x = np.array(poly)
    y = np.zeros(r+_sage_const_1 )
    y[_sage_const_0 ] = _sage_const_1 
    y[r] = -_sage_const_1 
    print(y)
    res = np.polydiv(x,y)

    return res[_sage_const_1 ]

# tested against the wolframalpha ord function
""" calculates the multiplicative order of r mod n"""
def ordr(r,n):
	if gcd(r,n) != _sage_const_1 :
		return -_sage_const_1 

	result = _sage_const_1 

	k = _sage_const_1 

	while (k < n):
		result = (result * r) % n

		if (result == _sage_const_1 ):
			return k

		k = k + _sage_const_1 	

	return -_sage_const_1 		




def find_r(n):
    limit = int(np.ceil((np.log2(n)) ** _sage_const_2 ))

    r = _sage_const_2 
    while _sage_const_1 :
        found = True
        for k in range(_sage_const_1 , limit):
            if n % r == _sage_const_1 :
                found = False
                break
        if found:
            return r
        r += _sage_const_1 

def smallest(n):
	m = max(_sage_const_3 ,math.floor(math.log2(n)**_sage_const_5 ))
	r = _sage_const_2 
	while r <= math.floor(m):
		c = _sage_const_0 
		b = math.floor(math.log2(n))**_sage_const_2 
		for k in range(_sage_const_1 ,b):
			if (n**k) % r ==_sage_const_1 :
				c = c + _sage_const_1 
		if c ==_sage_const_0 :
			break
		r = r + _sage_const_1 			
	return r
		
def check_perfect_power(n):
	if perfect_power(n) == False:
		return False
	else:
		return True	


def fast_power_poly(base, power, r, Z_n):
    result = _sage_const_1 
    while power > _sage_const_0 :
        # If power is even
        if power % _sage_const_2  == _sage_const_0 :
            # Divide the power by 2
            power = power / _sage_const_2 
            # Multiply base to itself
            base = P.polymul(base, base)
            #base = P.polydiv(square, modulus)[1]
            # base = base mod (x^r-1)
            x = np.nonzero(result)[_sage_const_0 ]
            for i in x[x>=r]:
                if base[i] != _sage_const_0 :
                    base[i % r] += base[i]
                    base[i] = _sage_const_0 
            # Keep the coefficients in Z_n
            base = base % Z_n
        else:
            # Decrement the power by 1 and make it even
            power = power - _sage_const_1 
            # Take care of the extra value that we took out
            # We will store it directly in result
            result = P.polymul(result, base)
            #result = P.polydiv(mult, modulus)[1]
            #print(np.nonzero(result))
            x = np.nonzero(result)[_sage_const_0 ]
            for i in x[x>=r]:
                #print(i)
                if result[i] != _sage_const_0 :
                    result[i % r] += result[i]
                    result[i] = _sage_const_0 
            # Keep the coefficients in Z_n
            result = result % Z_n

            # Now power is even, so we can follow our previous procedure
            power = power / _sage_const_2 
            base = P.polymul(base, base)
            #base = P.polydiv(square, modulus)[1]
            x = np.nonzero(result)[_sage_const_0 ]
            for i in x[x>=r]:
                if base[i] != _sage_const_0 :
                    base[i % r] += base[i]
                    base[i] = _sage_const_0 
            # Keep the coefficients in Z_n
            base = base % Z_n

    return result

# x = [2,2,4,15,11]
# for i in x:
print(find_r(_sage_const_5 ),smallest(_sage_const_5 ))

def aks(n):
	if n < _sage_const_2 :
		return
    #STEP 1    
	if check_perfect_power(n) == True:
		return False
    #STEP 2    
	r = smallest(n)

    #STEP 3
	for k in range(_sage_const_1 ,r):
		if _sage_const_1  < gcd(k,n) and gcd(k,n) < n:
			return False
    #STEP 4        
	if n <= r:
		return True
    #STEP 5    
	limit = int(np.ceil(math.sqrt(r-_sage_const_1 ) * np.log2(n)))
	for a in range(_sage_const_1 , limit):
		base = [a, _sage_const_1 ]
		coefficients = fast_power_poly(base, n, r, n)
		check = np.zeros(len(coefficients))
		check[n % r] = _sage_const_1 
		check[_sage_const_0 ] = a
		if not (check == coefficients).all():
			return False

	return True	

#############################################################################

# x = []
# y = []
# for i in range(0,20001,100):
# 	start = time.process_time()
# 	aks_test(i)
# 	end = time.process_time()
# 	t = end - start
# 	y.append(t)
	
	
# x=[i for i in range(0,20001,100)]



# plt.xlabel("n")
# plt.ylabel("Time required")
# plt.plot(x,y)
# plt.show()



def aks_2(n):
    if n < _sage_const_2 :
        return
    #STEP 1    
    if check_perfect_power(n) == True:
        return False
    #STEP 2    
    r = smallest(n)

    #STEP 3
    for k in range(_sage_const_1 ,r):
        if _sage_const_1  < gcd(k,n) and gcd(k,n) < n:
            return False
    #STEP 4        
    if n <= r:
        return True
    #STEP 5
    l=floor((_sage_const_2 *sqrt(euler_phi(r))*log(n,_sage_const_2 )+_sage_const_1 ))
    for a in range(_sage_const_1 ,l):
        s =Integers(n) # define n in Z_n 
        R = PolynomialRing(s, names=('x',)); (x,) = R._first_ngens(1)# define the polynomial ring
        F = R.quotient((x**r)-_sage_const_1 )
        q = F((x+a))
        V = F((q**n))
        e = Mod(n,r)
        d = (x**e) + a
        if (V != d):
            return False
    return True            



for i in range(_sage_const_100 ):
    if aks_2(i):
        print(i)


